---
title: 【BZOJ3048】【Usaco2013 Jan】Cow Lineup
date: 2016-12-31 18:53:47
tags:
---

线段树即可。

<!-- more -->

首先，定义$nxt[i]$为和$a[i]$相同的下一个数的位置，$lst[i]$为和$a[i]$相同的上一个数的位置。

从大到小枚举删数后的最长完美序列在原序列中的右端点$r$，同时用线段树维护每个位置$i$是否对不同数的个数有贡献（也就是$nxt[i]$是否大于$r$），不难发现$r$左移之后只有$lst[r]$变得有了贡献。在线段树上寻找一个$i$使得$rank(r)-rank(i)>k+1$且$i$最大，最后数一下$[i+1,r]$中满足$a[p]=a[r]$的$p$有多少个来更新答案。

时间复杂度$O(n \log n)$，空间复杂度$O(n)$。

[Code](https://github.com/q234rty/OJ-Codes/blob/master/BZOJ/3048.cpp)